# Урок 2
# Циклы. Строки. Списки


# Цикл While

i = 0
while i < 5:
    a, b = input().split()  # Читаем пару чисел
    a = int(a)  # Преобразовываем числа в целые
    b = int(b)
    print(a * b)
    i += 1


# Операторы break, continue

# break - оператор завершения цикла
i = 0
while i < 5:
    a, b = input().split()  # Читаем пару чисел
    a = int(a)  # Преобразовываем числа в целые
    b = int(b)
    if a == 0 and b == 0:
        break  # Досрочно завершаем цикл
    print(a * b)
    i += 1
else:  # Выполняем, если цикл завершился не по условию break
    print('Выведено 5 пар чисел')

# continue - оператор перехода к следующей итерации цикла (если она есть)
i = 0
while i < 5:
    a, b = input().split()  # Читаем пару чисел
    a = int(a)  # Преобразовываем числа в целые
    b = int(b)
    if a == 0 and b == 0:
        break  # Досрочно завершаем цикл
    if a == 0 or b == 0:
        continue  # Переходим к следующей итерации
    print(a * b)
    i += 1
else:  # Выполняем, если цикл завершился не по условию break
    print('Выведено 5 пар чисел')


# Цикл for

for i in 2, 3, 5:
    print(i * i)

for i in range(10):
    print(i * i)

# range - функция, возвращающая последовательность
# Параметры: начальный элемент, верхняя граница, шаг
# По умолчанию первая граница равна нулю, параметр шага равен единице

# В Питоне левая граница включается в интервал, правая граница не включается в интервал

n = int(input())
for i in range(n):
    print("*" * n)


a, b = input().split()  # Чтение для двух чисел


for i in range(a, b + 1, 2):  # Цикл с шагом 2
    s += 1


(a, b) = (int(i) for i in input().split())  # Для каждого из введенных параметров применяем функцию int

# ------------------------------------------------------------------------------------------------------

# Строки и символы

# Работа со строками
genome = 'ATGC'

genome[0]
genome[1]
genome[2]
genome[3]

# Индексация с конца
genome[-1]
genome[-2]
genome[-3]
genome[-4]


i = 1
print(genome[i])


# Строки неизменяемы
# genome[1] = 'G' ' Ошибка!


for i in range(4):
    print(genome[i])


# Пускай симвод c принимает все значения, которые есть в строчке
for c in genome:
    print(c)


# CACCTGGAC
# GATTACA
# Сколько раз встречается символ C?


genome = input()
print(genome.count("C"))
# Количество символов в строке C

# Метод - функция, которая применяется к некоторому объекту

s = 'ghjKLiuYh'
p = 'cc'
s.count(p)  # Сколько раз стока p встречается в строке s


s = 'aTGcc'
p = 'cc'

s.upper()  # Перевод в верхний регистр
s.lower()  # Перевод в нижний регистр
s.count(p)  # Сколько раз p встречается в s; считаются только неперекрывающиеся вхождения
s.find(p)  # Первое вхождение p в s
s.find('A')  # Если не входит, то результат равен -1
if 'TG' in s: do = 1 # Что-то делаем # Констртукция для проверки вхождения подстроки в строку
s.replace('c', 'C') # Заменяем все вхождения первой подстроки второй подстрокой


# Последовательные вызовы методов
s.upper().count('uy'.upper())


# Slicing - для взятия неких диапазонов символов
dna = 'ATTCGGAGCT'
# В интервалах левая граница включается, правая - не включается
dna[1]
dna[1:4]
dna[:4]
dna[4:0]
dna[-4:]
dna[1:-1]
dna[1:-1:2]  # 2 - шаг взятия символов
dna[::-1]  # Символы в обратном порядке


# Проверим строку на палиндром
s = input()
i = 0
j = len(s) - 1
is_palindrom = True
while i < j:
    if s[i] != s[j]:
        is_palindrom = False
    i += 1
    j -= 1
if is_palindrom:
    print('YES')
else:
    print('NO')


s = input()
r = s[::-1]  # Тратим память на новую строку!
if s == r:
    print("YES")
else:
    print("NO")


# Списки используются для хранения и манипуляции наборами значений
# Элементами списка могут быть произвольнрые значения
# При этом в рамках одного списка можно комбинировать объекты разных типов

students = ['Ivan', 'Masha', 'Sasha']
for student in students:
    print('Hello, '+ student)

# Доступ к элементам списка с помощью индексов
# Нумерация с нуля

# Длина списка: len(students)

# Так же как и со строками,
# м. использовать отрицательную индексацию
students[-2]
# или слайсы
students[:2]

# Или м. брать отрицательные индексы в слайсах.
students[::-1]

# ------------------------------------------------------------------------------------------------------

# Списки

# Операции со списками
# Сложение: сумма - список из сложенных списков
# Умножение на целое число: список в n раз больше, где изначальный список повторен в n раз


# В отличие от изученных ранее типов данных (int, float, str), списки (list) являются изменяемыми.
# Можно изменить конкретный элемент списка
students[0] = "Oleg"
print(students)


# Помимо явного изменения списка, можно добавлять элементы в список
students.append('Olga')
students += 'Olga'
# Список вполне может иметь повторяющиеся элементы
students += ['Boris, Sergey']

#  Метод extend добавляет в конец элементы другого списка.


# Пустой список
students = []


# Вставить элемент в середину списка
students.insert(4, 'Olga')
# Первый параметр - позиция, в которую вставляем элемент списка
# Второй параметр - сам элемент списка

print(students)


students = ['Ivan', 'Masha', 'Sasha']
students += ['Olga']
students += 'Olga'
# students = students + str("Olga")  # Ошибка!
students = students + list("Olga")  # Работает!
print(students)
print(students[:])
# Здесь все логично, ведь строка - это тоже список /неизменяемый/, где элементами списка
# являются символы, поэтому в наш список students слово Olga в третьей строке
# добавилось посимвольно.


# list.append(obj) вкладывает объект в конец листа, а += это тоже самое, что list.extend(iterable), то есть присоединяет каждый элемент iterable к листу. Делает что-то вроде:
L1 = []
L2 = [1, 2, 3]
for i in L2:
    L1.append(i)

# И списки, и строки - это последовательности
# (см. https://docs.python.org/3/library/stdtypes.html?highlight=mutable%20sequence#) .
#
# += складывает список с элементами последовательности ﻿по отдельности.
#
# А append прибавляет к списку новый элемент списка, сколько бы вложенных
# элементов в этом элементе ни было.


# Удаление элементов из списка

# Удаление элементов по значению
students = ['Ivan', 'Masha', 'Sasha', "Sasha"]
students.remove('Sasha') # Удаляет только первое вхождение параметра

# Удаление с помощью указания индекса
del students[0]

# Если удаляем несуществующий элемент или вне длины списка, то возникнет ошибка

# Поиск элемента в списке
if 'Ivan' in students:
    print('Ivan is here!')
if 'Ann' not in students: # Или not 'Ann' in students
    print('Ann is out')

ind = students.index("Sasha")  # Возвращает позиию, на которой стоит такой элемент
# ind = students.index("Ann")  # Элемента нет, поэтому сообщение об ошибке


# Сортировка списка

# Не изменяя порядка изначального списка
ordered_students = sorted(students)

# Изменяя сам список
students.sort()

# min()  # Минимальное значение в списке
# max()  # Минимальное значение в списке

# При этом все элементы списка должны быть сравнимы!
print(min(students))

# Список в обратном порядке
students.reverse() # Изменяет список
reversed(students) # Позволяет не изменять сам список

students[::-1]

students


# Присвоение списков
a = [1, 'A', 2]
b = a
a[0] = 42
b[2] = 30
print(a)
print(b)  # a и b имеют одинаковые значения!, хотя b мы не меняли


# Плюс, обратите внимания на два следствия.
# Например, если вы хотите создать список из пустых списков:
# a = [[]] * 8
# То все элементы будут указывать на одну область. И когда вы сделаете так:
# a[1].append(1)
# То вы запишите элемент в каждый вложенный список.
# И вторая деталь, что операторы s+= a и подобные для списков работают по другому, чем s = s + a.

a = [[]] * 8
a[1].append(1)
print(a)

# ﻿s = s + a создаёт в памяти новый объект-список, который является суммой s и a,
# и потом присваивает переменной s ссылку на этот новый список.
# s += a изменяет уже существующий список


# Генерация списков /list comprehention/

# Списки потенциально могут иметь огромное число элементов
# Поэтому задавать списки через запятую бессмысленно
a = [0] * 5
a = [0 for i in range(5)]
a = [i * i for i in range(5)]
a = [int(i) for i in input().split()]

# input читает строку
# split позволяет разделить строку по пробельным символам


# Двумерные списки

# Иногда требуется сохранить таблицу или матрицу
# Например, нужно сохранить студентов с их оценками по некоторым предметам
# Такие данные можно хранить с помощью двумерных списков

a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  # Строки по порядку
a[1] # Тоже список из элементов
print(a[1])
a[1][1] # Поскольку a[i] - список, то можно взять элемент
# первый индекс - номер строки
# второй индекс - номер столбца
print(a[1][1])


# Генерация двумерных списков

n = 3
a = [[0] * n] * n
print(a)
a[0][0] = 5
print(a) # Каждый a[0] является списком и содержит в качестве первого элемента число 5
# Произошло т.к. мы изначально создали список из [0, 0, 0], а потом a создали как n ссылок на этот список
# Т.е. каждый элемент списка a - это ссылка на один и тот же объект, состоящий из n нулей
# Поэтому любое изменение списка отражается на каждом элементе итогового списка a
# Таким образом, мы создали не матрицу nxn, а строчку из n элементов, и скопировали строчку n раз

a = [[0] * n for i in range(n)]  # Генератор списка
# Для каждого i заново генерируем список

# Или
a = [[0 for j in range(n)] for i in range(n)]


test = ['0','0','1','1']
res = ['1' if x == '0' else '0' if x == '1' else x for x in test]
print(res)
