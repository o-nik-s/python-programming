# Функции. Cловари. Интерпретатор. Файлы. Модули


# Функции

# Разбиение на логические части
# Сокрытие деталей реализации
# Переиспользование кода
# Создание новых "примитивов"

def min2(a, b):  # Ищем минимум из двух чисел
    if a <= b:
        return a
    else:
        return b

# def, имя функции, аргументы (параметры), тело функции, return

m = min(42, 30)
print(m)
m = min(min2(42, 30), 25)
print(m)

# Функция должна быть объявлена ранее первого вызова


# Различные функции
# Без возвращаемогоь значение
# Без параметров
# Произвольное число параметрво
# Параметры со значениями по умолчанию

# Проивзольное число параметров
def min (*a):
# Звездочка говорит о том, что функция может принимать произвольное число аргументов
# Все эти аргументы будут накапливаться в последовательности с именем a,
# и к этой последовательности мы можем обращаться - с помощью индексов или цикла for
    m = a[0]
    for x in a:
        if m > x:
            m = x
    return m

print(min(5))
print(min(5, 3, 6, 10))
print(min([5, 3, 6, 10]))

# Значения параметров по умолчанию
print(min(5), end="")
print()  # end по умолчанию не указывается

def my_range(start, stop, step=1):
# Два обязательных параметра и один не обязательный, который по умолчанию равен 1
# Будем возвращать список
    res = []
    if step > 0:
        x = start
        while x < stop:
            res += [x]
            x += step
    elif step < 0:
        x = start
        while x > stop:
            res += [x]
            x += step
    return res

print(my_range(15, 2, -3))
print(my_range(2, 15, 3))
print(my_range(2, 15))

# Перндача параметра по имени
# print: end = ""
# Если не указываем - передаются в том порядке, в котором записаны в заголовке функции
'''Здесь можно писать текст, не указывая каждый раз решетку'''

print(my_range(stop=20, start=5))
# Переставили аргументы, но все равно все будет вычислено верно за счет их явного задавания


# Локальные переменные
def init_values():
    a = 100
    b = 200

init_values()
# print(a + b)  # Ошибка, т.к. переменные не объявлены


# Изменения переменных внутри функции происходят с локальной переменной

# Но! Если переменная - изменяемая значение, например, список, то можем изменять
def append_zero(xs):
    xs.append(0) # Добавляем новое значение
    # Разные именения!!!

a = []
append_zero(a)
print(a)
# Переменная a изменится!!!


def append_zero(xs):
    xs.append(0) # Добавляем новое значение /теперь a = 0/
    xs = [100] # Cвязываем с новым объектом, теперь связи с a нет
    # Разные именения!!!

a = []
append_zero(a)
print(a)
# Переменная a изменится!!!


# Глобальные переменные
def print_value():
    print(a) # Локально не определена, поэтому будет печатать глобальную переменную

a = 5 # Объявили глобальную переменную
print_value()

# Однако если внутри функции изменяем значение переменной, то она уже считается глобальной
def print_value():
    global a # Для изменения необходимо об этом прямо объявить!
    print(a)
    a = 10
    print(a)

a = 5
print_value()

# nonlocal !!!

'''Присваиванием переменной нового списка невозможно изменить исходный список. Почему? 
Потому что для этой переменной изменяется ссылка со старогосписка на новый. Эта операция стоит за оператором присваивания.
Изменения в старом списке можно совершить через операции над элементами (тем же присваиванием l[i] = l[i]//2 - 
так как изменяется элемент, находящийся в списке. В списке хранится ссылка на объект переменная, а в ней ссылка на значение. 
Мы меняем вторую ссылку, которая начинает смотреть на новое значение, но список продолжает смотреть на этот объект.
Так же работает и пример со срезками - потому что изменяются все элементы из списка. Аналогично работают операции 
над списком .append(), reremove(), insert() и т.д.'''


# ------------------------------------------------------------------------------------------------------

# Множества
# Множества позволяют хранить некий набор данных и быстро отвечать на запрос,
# присутствует ли некоторый элемент в этом наборе данных.

# Множествам соответстввует тип данных set.
s = set() # создание пустого множества
# Если мы хотим создать множество и проинициализировать его элемента
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)
# Если перечисленные элементы содержали повторяющиеся значения, то результирующее множество
# содержит только одну копию каждого элемента
# Порядок элементов, которые мы записывали изначально в множество, и порядок элементов на выводе множества, различаются
# Для проверки, есть ли элемент в множестве
'orange' in basket
'python' in basket


# Операции с множествами

s = {1, 7, 5}
element = {10}

# Добавление элемента в множество
s.add(element)
# Удаление элемента из множества
s.remove(element)  # Если элемента нет, то возникнет ошибки
# Тоже удаление элемента, без ошибок
s.discard(element)
s.clear() # Удаление всех элементво из множества

len(s)  # Узнать число элементво в множестве

# Элементы множества можно перебрать с помощью цикла for
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
for x in basket:
    print(x)
# Каждый элемент вывелся только один рах, порядок элементов оказался не таким, как был изначально
# Для хранения порядка нужно использовать другие структуры данных, например, списки

# ------------------------------------------------------------------------------------------------------

# Словари

# Словарь позволяет хранить множество пар <ключ - значение>, и по значению в паре, т.е. по ключу,
# получать соответствующее ему значение.

# Обычный список может однозначно идентифицировать элемент по его индексу, т.е. позиции в списке.

# Однако часто идентификаторами элемента могут являться не обязательно числа.
# Например, нам нужна информация по модулю автомобиля.
# Тогда ключом будет являться номер автомобиля.

# Тогда ключом является строка из символов, а значением является то, что сопоставляется.

# Словари позволяют получать значение, где в качестве индекса мы берем ключ.



# Словарю соответствует структура данных dict.
dict(), {} # Создание пустого словаря
d = {'a': 239, 10: 100} # Созданрие не пустого словаря

# Получение доступа к элементам словаря по ключу
print(d['a'])
print(d[10])


# Операции со словарями
dictionary = {'a': 239, 10: 100}
key = 'с'
value = 537
print(key in dictionary)
print(key not in dictionary)
dictionary[key] = value  # Добавление значения в словарь
print(dictionary[key])  # Если кдюча нет, то вознгикнет ошибка
dictionary.get(key)  # Получение значения ключа без ошибки. По значению ключа вернет значение или NONE
del dictionary[key]  # Удаление элементов из словаря
print(dictionary)
# Так же как и в случае множеств, элементы в словаре не имеют порядке

# Словари
# Изменяемы
# Элементы не имеют порядка
# Все ключи различны
# Ключи неизменяемы

# Ключами могут быть числа строки, но не могут быть списки или другие словари

# Перебор элементов словаря
d = {'C': 14, 'A': 12, 'T': 9, 'G': 18}
for key in d:  # Все ключи словаря
    print(key, end="")
print()
for key in d.keys():  # Все ключи словаря
    print(key, end="")
print()
for value in d.values():  # Все значения словаря
    print(value, end=" ")
print()
for key, value in d.items():  # Все пары "ключ-значение"
    print(key, value, end="; ")
print()


# Словари можно использовать, чтобы для каждого ключа хранить несколько значений
# Для этого сопоставляем список значений

d["A000A78"] = ['Иван', 'Иванов']

# Если хочется посчитать для каждого элемента в наборе данных, сколько раз этот элемент встречается,
# мы можем ключу сопоставлять число - то, сколько раз этот элемент уже встречался. И тогда, когда
# число очереднрой раз встречается, мы можем увеличивать счетчик этого числа на единицу.

# ------------------------------------------------------------------------------------------------------

# Файловый ввод/вывод

# Чтение данных из файла
# Подключение файла
inf = open('file.txt', 'r')  # open('file.txt')
# file.txt - имя файла /при необходимости с путем/
# r - параметр, указывающий на то, чтот открываем файл для прочтения
# encoding="UTF-8" - учет кодировки
s1 = inf.readline()
s2 = inf.readline()
inf.close()

# Специальная конструкция для работы с файлом
with open('text.txt') as inf:
    s1 = inf.readline()
    s2 = inf.readline()
# Здесь файл уже закрыт

# Пара полезных функций

# Убирает все служебные символы при чтении строки
s = inf.readline().strip()
# '\t abc \n'.strip() -> 'abc'

# Строит полный путь к файлу /дабы указание пути работало в любой ОС/
os.path.join('.', 'dirname', 'filename.txt')
# './dirname/filename.txt'
# Требует модуля os

# Построчное чтение из строк
with open('input.txt') as inf:
    for line in inf:  # line будет принимать значения строки
        line = line.strip()
        print(line)

# Запись в файл
ouf = open('file.txt','w')  # 'w' - для чтения
ouf.write('Some text\n')  # Пишем строку
ouf.write(str(25))  # Пишем число
ouf.close()

with open('text.txt', 'w') as ouf:  # as ouf - связываем с файловой переменной
    ouf.write('Some text\n')
    ouf.write(str(25))


# В методах строк вообще-то есть проверки на букву или цифру: str[i:j].isdigit() и str[i:j]. isalpha ()
# S.isdigit() - Состоит ли (под)строка из цифр
# S.isalpha() -  Состоит ли строка из букв


# ------------------------------------------------------------------------------------------------------

# Модули. Подключение модулей

# Модуль содержит некоторые функции и данные в отдельном файле.
# Объекты из модуля можно импортировать в другие модули.
#
# Имя модуля определяется именем файла, в котором он записан:
# Имя файла = имя модуля + .py

# Импорт модуля:
# Рассмотрим файл my_module.py
# Пусть в нем описана функция foo()

import my_module
my_module.foo()

from my_module import foo
foo()

from my_module import *
foo()

from my_module import foo as my_foo
my_foo()


# Python распространяется с библиотекой стандартных модулей
# https://docs.python.org/3/library

# Для того, чтобы воспользоваться конкретным модулем / конкретной функцией, самый простой способ -
# это посмотреть по ключевым словам в стандартной библиотеке Python, поискать эти функции, и уже
# конкретно читать про необходимые функции.


# Модуль системных функций

# Модуль sys - содержит системные функции
# sys.argv - список аргументов командной строки

import sys
print(len(sys.argv))

# Если запускаем программу как python prog.py, то sys.argv - это просто имя программы.
# Если prog.py 5 -23, то имя и последующие аргументы.


# Модуль запуска внешних процессов

# Например, можно вызывать другую программу внутри Вашей программы

# Модуль subprocess

import subprocess

# Например, функция call
# subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False, timeout=None)
# Запускает программу в соответствии с аргументами (args).
# Дожидается выполнения и возвращает код возврата.

# Имя программы и список аргументов для программы
# Например,
subprocess.call(["python", "-h"]) # "-h" - аргумент
# Программа, в которой вызвали, выведет сообщение со справкой
# Запрос перенапраялвется на консоль

# Можно перенаправить вывод вызываемой программы в некий внешний файл, указав stdout="output.txt"


# Установка дополнитедьных модулей
# Библиотека requests - позволяет взаимодействовать с удаленными серверами
'''Для установки библиотек мы будем использовать менеджер пакетов conda,
который, в свою очередь, использует для установки пайтоновских библиотек
стандартный менеджер пакетов pip
Однако conda удобнее, потому как устанавливает не только питоновские библиотеки,
но и библиотеки, написанные на других ЯП.
Нам это будет полезно при установке numpy и matplotlib, где часть кода
написана на других ЯП.'''

# Для установки библиотеки:
# conda install requests

# Надо смотреть документацию конкретного модуля:
# docs.python-requests.org
# Раздел быстрый старт

import requests

r = requests.get('http://example.com')  # Простой get-запрос
print(r.text)  # Вывод ответа от пользователя
# Фактически получаем содержимое интернет-страницы, которая записана по этому адресу

# Пусть мы хотим передать запрос с параметрами
url = 'http://example.com'
par = {'key1': 'value1', 'key2':'value2'}
r = requests.get(url, params=par)  # Передача параметров в запрос; prams - словарь из параметров
print(r.url)

url = 'http://httbin.org/cookies'
cookies = {'ccokies_are': 'working'}  # Словарь
r = requests.get(url, cookies=cookies)  # Отправка сформированных cookies на сервер
print(r.text)

print(r.cookies['example_cookie_name'])  # Использование cookies, полученных от сервера
# Можно получать значения, так же рассматривая cookies как словарь


# ------------------------------------------------------------------------------------------------------

'''Библиотеки анализа данных'''

'''NumPy - работа с числовыми массивами
matplotlib - построение графиков
SciPy - функции для научных вычислений
pandas - таблицы (как matrix и data.frame в R)
Scikit-learn - алгоритмы машинного обучения
PythonSeaborn - визуализация статистических данных'''

# conda install numpy
# conda install matplotlib

